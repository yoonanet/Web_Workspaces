<!--
자바스크립트는 다양한 기능을 함수와 메소드의 개념으로 분리해서 정의를 해두고 있음
(이 의미들을 구분지어서 확인하도록 한다.)

함수: 객체지향과 상관없이 독자적으로 기능을 정의할 수 있다.
      기능과 행위를 정의한다는 것은 동일하지만 
      사용되어지는 문법요소들이 자바와는 다른 방향성으로 정의가 되어지고 있음. 

메소드: 자바는 클래스 안에서만 메소드를 정의할 수 있었음 
-->

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>함수</title>

<!-- 실습과 관련해서는 head태그 안에다가 통일성을 위해서 자바스크립트를 작성하도록 한다. -->
<script type="text/javascript"> /* !!자바스크립트는 갯수와 위치가 상관 없음!! */
/* 1. 함수의 개요 
    => 자바의 메소드(기능, 행위, 동작들을 미리 정의해두고 필요할 때마다 그 기능을 필요할 때마다 불러서 사용함)를 생각 */	
	// - 익명 함수   : 이름을 가지고 있지 않은 함수. 
	// - 선언적 함수 : 이름을 가지고 있는 함수.
	
	/* - 익명 함수의 정의
	     function는 함수를 정의할 수 있는 키워드, ()는 매개변수를 전달받기 위함, {}는 실질적으로 수행하고 싶은 기능을 작성
	var func = function(){ //이름을 가지지 않은 함수를 변수에 담아서 함수를 사용하도록 한다. (호출이 가능하기 위해서 변수에 담는 것임!!)
	//(내부에서는 함수를 정의하는 순간 메모리를 할당하면서 메모리 공간에 기능과 관련된 정보를 보관 => 시작주소값을 리턴하여 반환함
	// 즉, 변수에 시작주소값을 저장하는 것이다!!)
		var output = Number(prompt('숫자를 입력하세요', '숫자')); //prompt는 문자열을 리턴해주기 때문에 숫자형문자열을 Number을 통해 숫자 데이터로 변환함.
		alert(output); //사용자에게 입력받은 숫자를 출력		
	}; //위 코드는 변수명과 함수의 기능을 매핑하는 개념(함수의 선언 코드)으로써 실제로 실행되는 것이 아니다!! 착각하지 않기!!
	
	//함수는 아래와 같이 호출해야 함수가 실행이 되어진다.
	func(); //익명함수 호출 방법: 이름과 함께 ()를 표시해주면 됨.
	
	alert(func); //참조변수를 입력으로 넣어줬을 때의 결과: 작성된 소스코드가 출력됨.
	alert(prompt); //자바스크립트 제공 함수는 코드를 보여주는 것이 아닌 native code라는 인폼만 보여줌 => 소스코드(x)
	//익명함수 같은 경우 alert창에 넣으면 소스코드를 보여주게끔 동작이 되어지지만 자바스크립트 제공 함수는 소스코드를 보여주지 않는다.
	
	 
	// - 선언적 함수의 정의 : function키워드 다음에 함수 이름을 넣어주면 된다. (!!이름을 가지고 있기 때문에 변수에 담으면 안됨!!)
	function move(){ //익명함수에서 이름만 가지고 있다는 것만 차이점이고 나머지는 동일함!
		alert('move() 함수 호출');
	}; 
	
	//실질적으로 이 기능이 실행되는 시점은 함수를 아래와 같이 호출을 했을 때임.
	move(); // 선언적 함수 호출 방법: 함수 이름으로 다이렉트로 호출!!
	*/
	
	
/* 2. 함수의 재정의 	
	// 1. 익명함수의 재정의  
	//    자바스크립트는 마지막에 세미콜론(;) 붙여도 되고 안붙여도 됨. => 자바와 통일성있게 코드를 작성하기 위해서 함수 생성시 세미콜론 생략!
	//func(); 정의되지 않은 함수라고 에러나고 있음
	
	var func = function(){ alert('함수1'); } 	
	func(); //가까이에 있는 함수가 실행됨.
	
	var func = function(){ alert('함수2'); } //똑같은 변수 이름의 기능이 다른 함수를 정의함.
	//자바같은 경우 똑같은 이름에 대한 변수선언이 불가능했음. => !!유념해두기) 자바스크립트는 같은 이름의 변수선언이 얼마든지 가능하다!!
	//생각해보면 같은 이름의 변수를 작성할 수 있는 융통성을 제공해주지만 코드에 대한 모호성이 발생되어질 수 있는 아쉬움이 생김..
	//이 부분은 자바스크립트만이 가지는 고유의 특징이므로 유념하여 생각해두도록 한다.
	
	//변수는 하나의 값만 저장할 수 있다. 그러므로 함수에서 같은 이름의 변수를 작성했을 때, 마지막으로 작성된 함수의 주소값을 가지게 된다.
	func();

	
	// 2. 선언적 함수의 재정의
	//    - 웹브라우저는 script 태그 내부의 내용을 한 줄 한 줄 읽기전에 선언적 함수(!!static처럼 존재하고 있는지 제일 먼저 체크함!!)를 읽는다.
	//    - 따라서 둘째줄부터 읽음 -> 넷째줄을 읽음 -> 첫째줄 순서로 실행된다.
	move(); //첫째줄, 정상적으로 실행이 됨!!
	
	function move(){ alert('move() 함수1 호출'); } //둘째줄
	move(); //셋째줄, 마지막에 선언된 함수가 호출됨
	
	function move(){ alert('move() 함수2 호출'); } //넷째줄, 이름을 가진 함수 자체를 동일한 이름으로 선언하는 것도 가능함
	move(); //나중에 선언한 함수가 호출됨
	//어떤 의미와 의도로 동일한 이름으로 정의를 했었을때 에러를 내지 않고 처리를 하게끔 문법을 제공하고 있는지를 파악해야함.
	
	//!!선언적함수는 중복해서 정의하지 말라는 의도가 강하게 내포되어 있는 것이다!!
	//  실행되는 것을 봤을 때도 순서에 상관없이 마지막에 정의된 함수가 호출됨.
*/
	
	
	/* [자바스크립트만이 가지는 문법구문]
	실질적으로는 코드를 작성하다보면 첫 메인페이지 하나만 하더라도 수천라인이 작성됨.
	하나의 html파일에 있으면 분석을 하기 어려우므로 분리하여 코드를 작성하는 것이 일반적이다.
	동적인 효과를 부여할 때도 자바스크립트의 코드 길이는 어마어마하게 길어질 수 있음.
	스크립트의 코드는 갯수의 제한 없고, 위치에 상관 없이 작성이 될 수 있음
	서비스가 이루어지다 보면 추가적인 웹페이지의 수정사항이 발생이 돼서 업데이트를 해야하는 의뢰가 들어온다면
	첫 프로젝트를 작성할 때 담당자가 있을텐데 몇년이 지난 후에 유지보수가 맡겨진다면 대부분 담당자가 바뀌게 될 수 있음.
	이때, 그 담당자가 기존 코드를 완벽하게 분석한 후에 수정을 하기에는 시간적인 제약이 있어서 어렵다.
	그렇기 때문에 기능을 업데이트하는 부분에 포커스를 맞춰서 함수를 정의하게 된다. 
	-> 그때 정의하려는 함수가 존재하고 있는지를 확인하여 정의하는 것이 맞긴하지만
	   자바스크립트 입장에서는 개발자의 편의성을 생각하여 같은 이름으로 정의하는 것을 문법적으로 허용하도록 함.
	   즉, 자바스크립트는 유지보수에 있어서 함수끼리의 충돌을 방지하기 위함의 의도이다.
	       -> 익명함수는 가까이에 있는 함수를 호출하는 방식이기 때문에 충돌이 안된다!!
	
	주의) 익명함수는 가까이에 있는 함수를 호출하지만 선언적함수는 마지막에 정의된 함수가 호출됨 (익명과 선언적 함수의 두드러진 차이점임)
	
	익명함수는 순차적으로 코드를 실행하면서 만들어지고, 선언적함수는 전체코드가 실행되기 전에 만들어진다.
	
	이곳저곳에서 불려지는(여러 라인에서 호출이 이루어지는) 함수라고 한다면 지금처럼 충돌이 날 수 있음
	-> 가급적으로 html코드 내부에서 사용하지 말라고 한다면 선언적함수로 정의를 해줘야 함.
	   (각각 작성된 코드실행의 흐름을 예측하기 힘들기 때문이다.) 
	*/

	
/* 3. 매개변수와 리턴 값 
	function f(x){ return x * x; } //return => 함수를 호출해준 쪽으로 복귀
	//매개변수를 선언할 때 (var x)로 선언하는데 변수는 하나의 키워드를 사용하기 때문에 생략하도록 한다.

	alert(f(3));
*/	

/* 4. 매개변수(함수선언시 값을 전달받을 수 있도록 처리)
	// - 두번째 매개변수는 무시한다.
	
	//자바스크립트는 정해진 매개변수만 전달 받게끔 함수가 정의되어져 있다고 하더라도 매개변수를 달리 호출할 때 에러를 내주지 않고
	//정해진 매개변수에서 벗어난 나머지는 무시해버린다. 
	//즉, 자바스크립트는 융통성적인 측면에서 에러를 내지 않고 전달받은 갯수만큼만 내부에서 자체적으로 처리해주는 것이다.
	alert('원래 매개변수입니다.', '추가된 매개변수입니다.'); // 에러가 안나고, 첫번째로 지정해준 매개변수만 출력됨.
	//alert(): 하나의 값을 매개변수로 전달받게끔 정의되어져 있음.


	// - 두번째 매개변수는 undefined가 된다. 
	//    -> 이는 정의가 안되어져 있는 것으로 전달된 부분을 출력하지 않도록 하면서 정상적인 수행이 됨.
	var input = prompt('이름을 입력하세요.'); 
	//prompt()는 두개의 매개변수를 입력받게끔 정의되어져 있음
	alert(input);
	//이렇게 엄격하지 않은 문법으로 초창기에 범할 실수들을 프로그램 내부에서 융통성있게 동작되도록 처리되는 것임. => 이 편의성들을 무조건적으로 활용하지 말기.
		
	// - 매개변수 불일치 사용 예
	//   . Array() 함수는 기본적으로 매개변수에 아무것도 입력하지 않게 설계됨.
	
	var array1 = Array(); // 빈 배열을 만듦.(자바스크립트에서 자주 만날 코드)
	// 빈 배열에 대한 의미: var키워드는 변수 선언으로 하나의 키워드로 모든 자료형들을 담을 수 있음.
	//                      즉, 데이터를 담기 전까지 변수는 자료형이 확정되지 않은 것이다.
	//                      배열이라는 자료형으로 확정을 시켜주는 의미인 것이다.
	//                      나중에 배열이라는 자료형을 담을 것으로 확정을 지어주는 것으로 자료형의 초기화를 해주는 것임.
	var array2 = Array(10); // 한 개의 값이 들어올 때는 매개변수 만큼의 크기를 가지는 배열을 만듦.
	//10개의 공간만을 할당하면서 시작주소값을 array2변수에 담는다. => 결과창에서는 쉼표를 통해 공간만을 할당한 것을 확인할 수 있음
	var array3 = Array(25, 35, 45, 55); // 매개변수 자체를 배열로 만들어서 저장을 하게끔 처리가 되어짐.
	// 네 개의 공간을 만들어 데이터를 담고, 그 시작주소값을 변수에 담는다.
	
	alert(array1+'\n'+array2+'\n'+array3);
*/	

/* 5. 가변 인자 함수 
	// - 매개변수의 개수가 변할 수 있는 함수.
	// - 자바스크립트는 매개 변수의 개수를 정의된 것과 다르게 사용해도 괜찮지만, 
	//   매개 변수로 선언된 형태와 다르게 사용했을 때도 매개변수를 모두 활용하는 함수를 뜻함.
	
	//위와 같이 활용이 가능한 이유는 자바스크립트가 내부에서 arguments 변수를 자체적으로 생성해주기 때문이다.
	//1. arguments(.length을 호출한다는 것은 참조자료형일 수도 있겠다고 생각) 변수 사용 예제
	
	//함수를 정의하는 즉시 자바스크립트는 내부적으로 arguments(객체임)를 자동 생성해주게 된다.
	//!!입력의 인자값으로 데이터가 전달되어져 오면 그 데이터를 보관할 용도이다!!
	function sumAll(){ 
		alert(typeof(arguments) + ' : ' + arguments.length); //typeof(): 입력으로 전달되어지는 것에 대한 자료형을 알려줌 -> 선언하지 않은 변수는 typeof실행 시 에러남.
		
		//arguments는 객체라서 .을 통해 다이렉트 접근이 가능한 것이고, 
		//지금 전달받은 매개변수의 갯수를 length 필드에 보관하게 된다.
		
		for(var i in arguments) {
			alert(arguments[i]);
		}
	}
	
	sumAll(1, 2, 3, 4, 5, 6, 7, 8, 9); //매개변수를 입력으로 전달받게끔 정의해놓지 않았지만 에러가 나지 않음.
	
	
	//2. 입력 매개변수를 모두 더해 리턴하는 함수
	function sumAll() {
		var willReturn = 0;
		
		for(var i in arguments) { 
			willReturn += arguments[i]; //누적하여 저장.
		}
		
		return willReturn;
	}
	
	//매개변수를 전달받지 않게끔 정의가 되어져 있지만
	//함수를 호출해주면서 데이터를 전달해주게 되면 이 모든 데이터들이 arguments에 보관되고 
	//이를 반복누적하여 결과값으로 출력하도록 함!!
	alert(sumAll(1, 2, 3, 4, 5));
*/
	
/* 6. 리턴값: 함수 내에 복귀, 복귀할 때 값을 가지고 복귀의 동작의미를 담고 있음 
	function returnTest() {
		alert('문장A');
		return; //함수를 호출한 쪽으로 복귀하게 됨.
		alert('문장B');
	}
	
	var value = returnTest();
	alert(typeof(value) + ' : ' + value);
	//return을 하면서 아무런 값을 가지지 않고 반환을 하게 되면 담긴 값이 없음. 이를 변수에 담도록 한다.
	//선언한 변수에 아무런 값이 담기지 않았을 때 반환 타입이 undefined로 출력된다.
*/	

/* 7. 내부 함수 
	// 1. 제곱을 구하는 함수
	function square(x) { return x * x; } //매개변수 하나를 전달받아서 제곱을 해주는 함수
	
	// - 피타고라스 함수: 직각삼각형에서 밑변 제곱 + 높이 제곱에 루트를 씌움 -> 빗변의 길이를 구하기 위함 
	function pythagoras(width, height) {
		return Math.sqrt(square(width)+square(height)); //Math안에 sqrt()함수를 호출
	} 

	alert(pythagoras(3, 4));
	
	// =================================== (아주많은 코드가 작성됨)
	
	//누군가가 유지보수를 목적으로 같은 이름의 함수를 정의한 상태.(B개발자는 같은 이름의 함수가 있는지 살펴보지 못함)
	function square(width, height, hypoteunuse){ //피타고라스의 기능에 적합한 함수인지를 체크하기 위한 기능
		if((width*width) + (height*hight) == (hypoteunuse*hypoteunuse)) {
			return true;
		}else {
			return false;
		}
	}
	
	//이전에 정상적으로 동작되던 것들이 제대로 동작이 안됨.
	alert(square(4, 7, 9));//제대로 동작
	//선언적함수를 정의하는데 square함수가 똑같은 이름으로 정의를 하면서 이전 동작들이 제대로 동작이 안되는 것임.
	//자바스크립트는 실행 전에 선언적 함수를 먼저 보는데 마지막에 선언된 square함수만 기억을 한다.
	//pythagoras를 실행하면 square의 값을 전달받을 때 마지막 square함수를 바라보게 됨.
	//마지막 square함수에는 값이 전달되지 않았기 때문에 false를 반환하고 그 값을 가져간 pythagoras는 0으로 반환하게 됨.
	

	// 2. 내부 함수 사용 예제(해결 방법)
	//	- 피타고라스 함수
	function pythagoras(width, height) {
		function square(x) { return x * x; } //함수 안에 함수로 정의(유지보수를 할 수 있을만한 함수를 내부함수로 정의함.)
		
		return Math.sqrt(square(width)+square(height)); //호출 시 가까운 함수를 먼저 쳐다보기 때문에 정상적으로 실행이 된다.
		//!!함수 내부에서 내부 함수를 호출할 때, 내부 함수가 함수의 외부에 내부 함수와 같은 이름이 있을 때, 내부 함수가 우선적으로 호출된다!!
	} //주의) 내부함수로 정의한 것은 외부에서 호출하여 사용할 수 없다.
	
	alert(pythagoras(3, 4));
	alert(square(5)); //정의되지 않은 함수로 에러남 -> 외부에서 호출 불가.
*/

/* 8. 함수를 매개변수로 전달받는 함수 
	// 1. 익명함수를 매개변수로 전달
	
							// var otherFunction = function(){} 익명함수 선언을 하면서 변수에 담는 것과 동일함!!
	function callFunctionTimes(otherFunction){
		
		for(var i = 0; i < 5; i++) {
			otherFunction();
		}
	}
	
	callFunctionTimes(function(){ alert('Hello JavaScript!'); }); //입력으로 익명 함수를 다이렉트로 전달할 수 있다.
	
	//이러한 동작 구문을 자바에서도 활용할 수 있도록 8버전부터 람다식, FunctionalInterface(함수적 인터페이스)으로 제공을 하고 있는 것이다.
	//↑ 원래의 자바는 간단한 기능도 인스턴스를 생성하여 참조변수를 전달을 했었어야 했었음 -> 배보다 배꼽이 더 큼 
	//람다식 이후 활용할 수 있는 스트림의 기능들로써 확장을 해나가고 있음.

	// 2. 선언적 함수를 매개변수로 전달
	function callFunctionTimes(otherFunction){
		for(var i = 0; i < 5; i++) {
			otherFunction();
		}
	}
	
	function justFunction() {  //별도로 선언적 함수를 정의
		alert('Hello, JavaScript!');
	}
	
	callFunctionTimes(justFunction); //정의된 함수의 이름만 입력으로 전달해주도록 하면 된다.
*/		

/* 9. 함수를 리턴하는 함수와 클로저 
	//1. 익명함수를 리턴하는 함수
	function outerFunction(){
		return function(){ alert('Hello JavaScript!'); }
		//반환형을 함수로 정의할 수 있음 => 함수의 주소값을 리턴하는 형태가 되는 것이다.
	} 
	
	//함수 호출과 동시에 리턴되어지는 함수를 호출하고 싶을 땐 ()를 한번더 추가적으로 써주면 됨.
	outerFunction()(); 
	//즉, 리턴되는 함수 자체를 다이렉트로 호출해주려면 
	//    한번 더 ()를 호출해주면 리턴되어지는 함수가 호출이 되어지게 되는 것이다.
	
	//2. 오류코드: 지역변수의 유효범위 (자바에서 살펴봤던 개념과 일치 -> stack영역에 임시보관의 개념)
	function test(name){ //function은 중괄호 안에서 자신의 영역을 가진다.
		//output변수는 지역변수로 영역 내에서만 유효함. 영역을 벗어나는 순간 자바스크립트에 의해서 소멸됨
		var output = 'Hello, ' + name + '!'; //키워드에 범위를 가지는 변수를 지역변수라고 불러줌. 
		                                     //=> 특징) 수행이 끝나고 영역을 벗어나는 순간 프로그램에 의해서 소멸됨 (자바와 동일)
		return output;
	}
	
	alert(test('홍길동'));
	alert(output); // error
	//출력에서 변수가 정의되어져 있지 않다라는 에러가 남 
	//-> test영역 안에 선언된 변수의 개념으로 유효범위를 벗어나면 
	//   소멸되어지고 없는 변수이기 때문에 위와 같은 메시지가 출력된다는 것을 알 수 있음
	
	
	// 3. 클로저(Closure) -> 포괄적인 의미를 담고 있음
	//    - 지역변수를 남겨두는 현상.(좁은의미)
	//    - 살아남은 지역변수 output.(좁은의미)
	//    - 리턴되는 함수 자체.(넓은의미)
	function outerFunction(name) {
		var output = 'Hello, ' + name + '!';
		return function() { return output; }; //output에 담겨진 값을 함수를 통해 반환하도록 한다.
	}
	
	var first = outerFunction('이순신'); //first는 내부함수가 저장이 되어지는 것임
	
	//리턴해서 담아주게 되면 output변수는 소멸될 것인데, 출력할 때 잘 보관되고 있음 => 이것을 Closure이라고 불러주고 있다.
	//함수를 선언하면서 그 안에 있는 변수는 지역변수가 맞고 지역변수는 복귀하기 직전에 소멸되는 것이 맞음
	//=> 함수에 담겨진(리턴되어진) 값 자체를 별도에 메모리에 보관하게끔 내부적으로 처리가 되어져서 
	//   함수를 호출했을 때 문제없이 결과가 잘 출력되어지는 것이다. 이 개념이 Closure이라고 하는 것이다.
	alert(first()); //저장된 내부함수를 호출하도록 한다.

위까지가 문법적인 사항이다. */

/* 10. 자바스크립트 내장 함수 -> 자바스크립트가 기본적으로 유용하게 사용할 만한 기능들을 미리 정의해둔 함수들 
// 1. eval(string) : string을 자바스크립트로 실행.
//                   문자열 데이터로 전달되어지는 것들을 명령어로 해석하여 프로그램을 실행시켜주는 함수이다.
	var willEval = ''; //자료형을 문자 혹은 문자열로 초기화
	
	willEval += 'var number = 10;';
	willEval += 'alert(number);'; //데이터는 문자열을 누적해서 변수에 담아주는 것임.
	
	alert(willEval); //문자열 그대로 출력
	eval(willEval);  //!!문자열데이터를 코드의 명령어로 이해를 하여 프로그램이 실행이 되어짐!!
		
// 2. isFinite(number)
//   - number가 무한한 값인지를 확인한다.
//	 - 자바스크립트는 0으로 숫자를 나누면 Infinity(변수)라는 값이 들어감.	
	
	
	
// 3. isNaN(number)
//	 - number(입력으로 전달되어진)가 NaN(Not a Number:변수)인지 확인한다.
//	 - 자바스크립트가 표현할 수 없는 숫자를 의미한다.

	var num1 = 10 / 0;   //infinity
	var num2 = 10 / 'A'; //NaN
	alert(num1 + ' : ' + num2);
	alert(isFinite(num1) + ' : ' + isNaN(num2));

	
	var value = 10 / 0; //0으로 나눴는데도 value is not Infinity가 출력됨.
	alert(value + ' : ' + isFinite(value));
	//양의 infinity값이 있고 음수일 경우 -infinity의 값이 존재한다. => 이때 false의 값이 반환된다.
	//!!양의 infinity와 음수의 infinity는 피드백되는 결과값이 다르다는 것을 유의하도록 한다!!
	//무한할 때는 false를 반환해주는 것이고, 유한한 숫자일 때는 true를 반환해준다.
	
	//음수값을 0으로 나눴을 때에는 -infinity를 반환하기 때문에 원하는 값대로 도출되지 않을 수 있음
	//if(value == Infinity){
	if(isFinite(value) == false){ //이렇게 코드를 작성해줘야 의도한 결과값을 출력받을 수 있다.
		alert('value is Infinity');
	} else {
		alert('value is not Infinity');
	}
	
	
	// - NaN 값의 비교 : NaN은 스스로를 비교할 수 없다.
	var num3 = 10 / 'A'; //숫자값을 문자와 나눌 수 없음. 이러한 연산은 결과값을 NaN으로 반환해주게 된다.
	alert(num3);
	
	//if(num3 == NaN) {
	if(isNaN(num3)) { 
		alert('num3 is NaN');
	} else {
		alert('num3 is not NaN');
	}
	//주의) '=='은 비교연산자임. 피연산자가 숫자형 데이터일때 수행이 되어지는 연산자이다.
	//      NaN은 데이터가 숫자가 아니다. 숫자가 아니기 때문에 false가 출력되는 것이다.
	//      따라서 NaN은 스스로 비교할 수 없기 때문에 isNaN함수를 통해서 
	//      NaN이 맞을 때는 true, 아닐때는 false를 반환받으면서 원하는 바를 도출받도록 한다.
*/	
	
/* 4. Number() 함수: 입력으로 전달되어진 다른 자료형(문자형 숫자)의 값을 숫자형으로 형변환을 하여 반환해주는 기능 	
	var won = Number('1000'); //prompt함수와 유용하게 사용되어짐 -> 사용자로부터 입력받은 문자형숫자를 사용하고자할 때 활용
	alert(typeof(won) + ' : ' + won); 
*/

/* 5. parseInt() 함수 & parseFloat() 함수 
	var won = parseInt('1000원'); //Number()와 유사한 동작을 수행하는 함수이다.
	//차이점은 입력으로 전달된 값이 숫자형 문자열 데이터인데 여기에 텍스트가 함께 포함이 되어져 있다고 한다면
	//         Number()함수는 제대로 처리를 해주지 못함. parseInt()함수는 수치형과 텍스트가 일부 포함되어져 있다고 하더라도
	//                                                   숫자값만 꺼내와서 정수형으로 형변환을 하여 변수에 담으면서 정상적인 처리를 해줌.
	var dollor = parseInt('$1000'); // Number라는 자료형을 보여주지만 숫자가 아니라는 결과값을 반환함
	//주의) 수치형에 데이터가 먼저 올 때만 가능하고, 숫자형이 뒤에 오고 앞에 문자나 특수문자가 오면 수치형으로 변환을 해주지 못한다.
	//      즉, 뒤에 특수문자가 오면 가능함!!
	
	alert(typeof(won) + ' : ' + won);
	alert(typeof(dollor) + ' : ' + dollor);
	
	dollor = parseFloat('10.5$'); //실수형 문자열 데이터를 Number로 형변환하여 실수값으로 출력할 수 있도록 한다.
	alert(typeof(dollor) + ' : ' + dollor);
*/	



	
	
</script>
</head>
<body>

</body>
</html>