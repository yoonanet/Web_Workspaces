<!--
	자바스크립트에서는 브라우저를 관리하는 window 객체가 있고,
	window 객체 안에 screen, location, navigator, history의 객체들이 제공되고 있었다.
	거기에 추가적으로 Document객체가 있다. => 관리하는 주체가 무엇인지를 살펴볼 예정이다.
	
	html을 통해 뼈대를 만들고 그 뼈대를 꾸며주기 위해서 CSS 문법요소를 이용한다.
	꾸며줄 대상에 접근하기 위해서 선택자를 활용했다. 그 선택자를 활용해서 스타일들을 적용했었다.
	자바스크립트는 그 뼈대를 대상으로 동적효과를 부여하고 싶은 것이다. (가장 기본적)
	동적효과를 부여하고 싶은 대상을 어떻게 접근할 수 있는지 방법을 알아야 한다.
	또한, 동적효과를 부여할 때 처음에 보여진 화면상에 뭔가의 이벤트가 발생이 됐을 때 
	      그 순간 특정 메시지를 출력하게 한다던지, 특정 태그들을 출력한다던지 하는 이러한 동작들이다.
	그러한 동적 처리를 하도록 하는 주체가 DOM(실질적인 동적효과를 부여하는데 있어서 핵심기능이 됨)인 것이다.
	
	* 문서객체모델(DOM, Document Object Model) = 실질적인 동적 효과 부여에 있어서 중요한 역할!!! (이를 위하여 앞의 문법 요소를 공부)
	  - 넓은 의미:웹브라우저가 HTML 페이지를 인식하는 방식.
	  - 좁은 의미:document 객체와 관련된 객체의 집합.
	  - 이미 만들어진 HTML 페이지에 태그를 추가, 수정, 제거할 수 있음. => 이미 완성된 정적인 화면에서 특정 태그를 추가, 수정, 제거되기 때문에 동적효과가 부여되는 것이다.
	  - 기본적인 자바스크립트만으로 DOM을 다루기에는 너무 복잡하므로, 간단한 내용만 살펴보고 자세한 내용은 jQuery와 함께..
	   => 기본적으로 많이 활용되는 동적인 기능들을 jQuery라는 라이브러리 형태로 제공(함수나 메서드의 형태로)을 해주고 있다. 
	      따라서 자바스크립트를 이용할 때는 jQuery를 사용하는 것이다!!

	* DOM 관련 용어
	  - 문서 객체:html or body 태그를 자바스크립트에서 이용할 수 있는 객체로 만들면 그것이 문서 객체.
	  - 노드: 각 요소(head, body, title, script, h1, HEADER ...) => document에서는 html의 앨리먼트를 노드라고 불러준다.
		. 요소노드(Element Node):HTML 태그. => 이미지 자체는 단일태그로 시작과 끝태그에 아무것도 필요하지 않기 때문에 요소노드라고 불림
		. 텍스트노드(Text Node) : 요소노드 안에 들어 있는 글자.
	  - 정적으로 문서 객체를 생성한다의 의미
		: 웹페이지가 처음 HTML 페이지에 적혀있는 태그들을 읽으며 생성하는 것.
	  - 동적으로 문서 객체를 생성한다의 의미
		: 자바스크립트를 사용해 원래 HTML 페이지에는 없는 문서 객체를 생성하는 것.
		
자바스크립트에서는 DOM의 원리와 개념의 설명 위주로 살펴볼 예정이다. -->


<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>문서객체모델</title>
<script type="text/javascript">
window.onload = function(){ //body영역을 다 읽어갔을 때 이벤트를 발생시키면서 함수가 호출되는 형식이다. -> 따라서 onload이벤트를 실습 영역 전체로 감싸주도록 한다.
							//그래야 body를 브라우저가 알고 있을 수 있기 때문에 onload이벤트를 통해 body영역이 다 실행이 된 이후에 코드들을 실행하도록 한다.
/* 1. 용어 정의 
//script에서 동적 기능을 적용해주기 위해서는 해당 태그 영역에 접근할 수 있어야 한다.
//css는 스타일시트에 선택자(selector)로 하여금 html 해당 영역 태그에 접근할 수 있었다. 
//이 스타일시트의 수행시점은 헤더 영역에 있다고 하더라도 바디영역에 내용들을 읽어오면서 
//브라우저가 화면상에 출력할 때는 바디영역에 해당되어지는 요소들이 있으면 선택자가 그 요소들을 보면서 스타일에 접근했음!!


//자바스크립트에서는 동적효과를 부여하고자 한다면, 동적효과를 부여하기 위한 해당 대상 요소가 먼저 존재하고 있어야 접근이 가능하다.
// 

//즉, 바디영역에 접근 대상이 존재하고 있어야 영역에 접근할 수 있음.( h1 에 접근하여 동적 효과 주고 싶을 때 -> body 영역에 존재하고 있어야함 ) 
//     => 이때 document객체를 이용해서 해당 태그 영역에 접근하도록 한다.

	// h1에 고유 아이디 존재. 이를 접근하려면 -> 아래와 같은 코드를 작성하도록 한다. 이는 "id의 속성이 적용되어 있는 요소에 접근"의 의미를 담고 있다.
	// 아래의 코드에서의 주의할 점) 자바스크립트 대소문자 구분한다!!
	var header = document.getElementById('header_1'); //document객체가 getElementById 입력으로 전달한 "id의 속성이 있는 엘리먼트 요소"를 선택해주게 된다.
													  //즉, document 객체가 body로 가서 해당 ID로 정의되어있는 element(시작과 끝태그까지의 영역)을 선택해주게 되는 것이다.	
	//document는 메소드를 통해서 이 요소(태그)의 정보를 내부에 메모리를 할당하여 자신이 필요한 정보를 저장해놓게 된다. 
	//-> 이후 시작 주소값을 return하게 된다!! -> 참조변수를 선언하여 저장하고 사용하도록 함.
	
	//메서드를 통해서 들어가면 클래스가 정의되어 있음 -> 클래스 안에 element에 대한 자기가 접근할 수 있는 정보를 new하여 클래스에 저장한것
	//이와 비슷한 동작 = Correction Framework의 Iterator을 생각하면 된다.
	//이제 변수(header)를 통하여 html 요소(태그)에 접근할 수 있게 되는 것 => 접근할 수 있는 애(=header)가 바로 document object
	
	//즉, 객체가 반환된다고 보면 됨. => 클래스라고 보고 필요한 정보를 가지고 있다가 시작주소값을 반환해서 변수에 담아주는 것으로 생각하도록 한다.
	//이렇듯 접근할 수 있는 객체가 Document Object(html에 접근할 수 있는 주체,객체)라고 불러주는 것이다.
	
	//header_1에 텍스트가 HEADER-1로 메시지를 출력하고 있다. 이 메시지를 바꿔주고 싶다고 한다면
	//header객체(객체이므로 필드/메서드 존재) 안에 innerHTML속성을 제공해주고 있음. => 데이터를 이 속성에 넣어주면 현재에 출력되어지고 있는 메시지를 수정(업데이트)해준다.
	header.innerHTML = 'Hello JavaScript!'; //지정한 메시지를 속성에 넣어주면 출력되어지는 메세지를 실시간적으로 수정해주는 것이다. -> 실행을 하면 전혀 변화가 없고 에러가 나고 있다.
	//왜 에러가 나고 있는가? 스크립트를 head코드 안에 작성을 한다면 크롬 브라우저는 HTML을 실행하는 즉시 위에서 부터 아래로 내용들을 읽어간다. 
	//                       -> 이때 이 코드를 만나면 html코드를 만나지 않았기 때문에 존재하지 않은 코드로 인식한다. 즉 위에 반환된 값이 null이 됨.
	//                               -> header 코드를 만나면 아직 'header_1' id가 존재하지 않음(body가 실행 안되었기 때문에) 
	// 								 -> null값에 .innerHTML을 호출하니 nullpointException이 되는 것
	//                       -> 제대로 동작이 되려면 body부터 읽어가서 브라우저가 body의 내용을 알고 있을 때 위에 코드가 실행이 되어져야 한다. -> 이때, 이벤트처리가 필요한 것이다. onload메소드로 감싸기
	//즉, 객체에 있는 innerHTML가 동적인 수정을 한 것이다!! ex) 체크되는 순간에 업데이트되도록 하는 코드.
*/	

/* 2. 문서 객체 생성1: 이미 만들어진 정적 페이지에 동적인 효과 -> 동적으로 태그를 추가하는 방법 
	// 1. 문서 객체 생성 => 현재 body에서 h1태그 뒤에 h2태그를 추가하려고 함.
	//    태그는 html에서 사용하는 용어이다. 자바스크립트에서는 문서 객체라는 용어를 사용한다.
	
	var header = document.createElement('h2'); 
	//createElement()메소드의 추가하고 싶은 태그의 정보를 입력으로 넣어주도록 한다. 
	//메소드 안에서는 태그를 추가하기 위한 정보나 필요한 내용들을 자체적으로 메모리를 할당해서 보관을 해둔다. 
	//-> 이후 시작 주소값을 반환해준다.(추가에 관련된 객체를 반환해주는 것이다.)
	
	//h2(제목의 성격을 부여함)태그의 특징은 텍스트가 꼭 있어야 한다. => 이러한 document를 텍스트노드라고 불러준다.
	//html의 element -> document에서는 node라고 칭함
	//h1~h6 텍스트가 반드시 필요 = 텍스트가 필요한 노드 = 텍스트 노드 / 텍스트가 꼭 필요하지 않은 노드 = 요소 노드
	
	//createTextNode: 텍스트노드를 처리하기 위한 메서드, 입력으로 출력하고 싶은 텍스트를 넣어줌
	var textNode = document.createTextNode('Hello DOM');  
	//=> h2에 넣을 문자열 관련하여 메모리에 보관 -> 보관하는 메모리의 주솟값을 저장하기 위해 변수 선언!!
	//   변수에서 정보들을 접근할 수 있는 필드/메서드가 있음. (객체를 반환받음으로써 그 안에 있는 메서드나 필드를 사용할 수 있도록 하는 것임)
	
	//이러한 동작원리가 자바에서 메서드 안에 클래스를 정의하는 것(local class)과 같은 개념이다. 
	//메서드 안에 정의를 하다보니까 외부에서는 접근할 수 없었음. 그렇기 때문에 인터페이스로 정의하여 클래스를 호출하도록 했음 => 이와 같은 원리가 여기서 똑같이 적용됨.
	
	
	//문제는 위 두 소스가 하나가 되어야 한다. document객체와 textnode를 연결해줘야 하는 작업이 필요하다.
	// 2. 노드(요소/텍스트)를 연결.
	//createElement, createTextNode 안에는 익명 클래스가 정의되어있음. 주솟값을 반환해주니 . 을 이용하여 메서드를 이용할 수 있는 것이다!!
	//createElement인터페이스를 통한 appendChild()메소드를 호출하도록 한다. => 이 메소드를 통해서 정보를 연결시키도록 한다.
	//=> 즉, 간단하게 말하자면 메서드를 통해 받은 객체 안에는 appendChild(= 자식을 연결하겠다) 메서드 존재 => 연결할 노드를 자식으로 바라봄
	header.appendChild(textNode); // 자식을 연결하겠다는 것이다. -> 텍스트 노드를 자식으로 연결하면 된다.
	//header를 입력으로 전달한 textNode와 연결해야한다는 정보가 전달이 된 것이다!!
	
	
	//위에 하나가 된 것을 화면상에 추가를 해주면 된다.
	//3. body 문서 객체(= 태그)에 header 문서 객체를 추가.
	//   body는 기본 틀로 항상 존재하는 태그(문서객체)이기 때문에 바로 접근할 수 있게끔 필드의 형태로 정의를 해서 제공을 해주고 있는 것이다.
	//   body는 필수라서 필드로 정의를 해두고 있기 때문에 용어 정의에서의 방법처럼 접근할 필요가 없다.
	document.body.appendChild(header); //연결을 할 때는 appendChild의 형식으로 추가를 해주도록 한다.
	//!!기존 body 영역에 있는 모든 영역 마지막에다가 header 문서객체를 추가를 해주게 된다!! 
	//위와 같은 방법이 동적으로 태그를 추가하는 방법이 되는 것이다.
	//활용) 나중에 display속성을 통해서 나타났다 사라졌다하면서 텍스트를 동적으로 추가하도록 하면 됨!!
	
	
	//실행 후 브라우저 element를 보면 h2 태그가 원래부터 있던 것처럼 코드가 적혀있음
*/		
	
/* 2. 문서 객체 생성2 
// - 텍스트 노드 갖지 않는 노드 생성하는 방법.
//	 1) 웹표준이 정의하거나 웹브라우저가 지원하는 태그의 속성에만 사용할 수 있다. (아래와 같이 직접적인 접근에 경우!!)
		//document의 객체를 생성함!! => 반환받은 것에 대한 자료형은 object임. (document의 메서드를 통해서 반환받은 img의 자료형 = Object.)
		var img = document.createElement('img'); //이미지 태그(문서객체)를 생성하도록 한다. => 별도의 텍스트노드가 필요없음 ; 향후에 추가할 이미지에 접근할 수 있는 객체임
		//어떤 이미지를 뿌릴 것인지에 대한 정보를 src속성을 통해 알려줘야 의미를 가지는 태그이다.
		
		
		//객체에 나중에 속성을 추가하려면 객체이름.키값 = '벨류값';으로 넣어주면 된다.
		//그 개념 하에 아래처럼 속성을 추가해주도록 한다. 
		img.src = './images/Koala.jpg'; //이미지 정보를 넣어주도록 한다.
		img.width = 500;
		
		document.body.appendChild(img); //body영역에 img를 연결하도록 한다.
		//동적으로 만든 코드를 소스코드의 맨 마지막에 추가되는 것을 확인할 수 있다.
		//클릭했을 때 이미지를 추가하고자 한다면 클릭이벤트에서 스크립트영역에 위 코드를 넣어주면 이미지가 짠하고 나타나게 된다. 


//	 2) 웹브라우저가 공식적으로 지원하지 않는 속성 => 위에처럼 나중에 추가하여 동적으로 사용할 수 없음. setAttribute 메서드 이용!
		var img = document.createElement('img'); 
		img.setAttribute('src', './images/Koala.jpg'); //공식적으로 지원하는 속성도 이렇게 작업할 수 있음(추가하고자할 속성과 값을 메서드에 대입)
		img.setAttribute('width', '500');
		//공식적으로 지원하지 않는 속성(사용자 추가 속성)을 추가적으로 추후에 넣어주고자 한다면 setAttribute를 통해 지정하도록 한다.
		img.setAttribute('data-property', '350'); 
		
		document.body.appendChild(img);		
*/

/* 2. 문서 객체 생성3  
// - 문서 객체의 innerHTML 속성 사용해 객체 생성.
	
	var output = '';
	
	output += '<ul>'; //코드를 텍스트의 형태로 변수에 누적하면서 직접적으로 담아줌 (ul태그는 목록을 구성해주는 태그이며, li자식태그를 통해 목록을 작성)
	output += '<li>JavaScript</li>';
	output += '<li>jQuery</li>';
	output += '<li>Ajax</li>';
	output += '</ul>'; 
	
	//기존의 내용이 지워져도 상관이 없다고 한다면 아래에 코드를 사용
	document.body.innerHTML = output; //변수에 담겨져 있는 값을 추가하도록 함.
	//해당 body에 innerHTML을 추가했을 때 기존에 body영역에 있던 내용들이 지워지면서 body영역내에 추가되어진 내용들만 작성이 된 것처럼 보여지고 있음
	//innerHTML의 속성을 이용하게 되면 body에 기존내용들이 지워지면서 코드가 추가되어진다.
	
	//기존 내용을 보존하면서 내용들을 추가하고 싶다고 할 때는 
	//div태그_문단을 구성하는 요소를 이용해서 id속성을 부여하여 innerHTML을 통해 업그레이드하도록 하면 된다!!
	
	//기존의 내용을 보존하면서 내용을 추가하고 싶다면 아래의 코드를 활용하여 누적의 형식으로 업그레이드하도록 한다.
	document.body.innerHTML += '<h1>Document Object Model</h>'; 
	//현재 innerHTML에 내에 누적을 해주면 기존 내용은 보존이 되면서 업그레이드되어지고 있는 것을 확인할 수 있다.
*/ 

/* 3. 문서 객체 가져오기1 
// - 웹페이지에 이미 존재하는 HTML 태그(문서 객체)를 자바스크립트로 가져오는 방법.
// - getElementById() 메서드는 한 번에 한 가지 문서 객체만 가져올 수 있다.

// - 웹 표준에서 정의하고 있는 바는 id(고유한 이름을 가짐)값은 한페이지 내에서 중복해서 사용하지 말라고 정의가 되어져 있었다.
//   중복해서 동일한 속성을 부여하고 싶을 때는 class선택자를 활용했었음.
// - 자바스크립트 영역 내에서 getElementById메서드를 이용한 document객체를 통해서 고유한 id값을 가지는 대상에 접근하기 위해서 제공해주는 메서드를 사용할 때
//   하나의 페이지 내에 중복되게 사용을 하고 있다면 정상적으로 동작이 되지 않는 문제가 발생하게 된다. => 따라서 id값은 중복이 되지 않는 것이 중요함!!

	// 문서 객체를 가져오도록 처리하는 코드
	//  => html태그에 접근할 수 있는 document객체를 생성 
	var header1 = document.getElementById('header_1'); //내가 접근하고자 하는 태그의 고유 이름을 넣어주도록 한다!
	//메서드로 생성한 document객체에 접근할 수 있도록 변수 이름을 붙여주도록 한다.
	var header2 = document.getElementById('header_2');
	
	// 문서 객체의 속성을 변경. -> 기존에 출력되고 있던 텍스트 노드가 현재 innerHTML을 통해서 업데이트한 텍스트로 변경하도록 한다.
	header1.innerHTML = 'Hello, JavaScript!'; //innerHTML를 이용해서 업데이트하고 싶은 출력 값으로 변경해주고자 함.
	header2.innerHTML = 'getElementById() 접근.';

	//그렇다면 모든 태그에 접근을 하기 위해서 id이름을 고유하게 붙여준다고 한다면 제약이 많음
*/	
	
	
/* 3. 문서 객체 가져오기2 
// - getElementsByTagName('tagName') 
//   : tagName과 일치하는 문서 객체를 배열로 가져옴. (입력으로 전달된 태그의 이름을 통해서 태그 목록을 검색하여 객체 가져옴)
//     태그의 이름으로 접근하는 방법에서 태그들은 한 페이지 내에 중복하여 존재할 수 있기 때문에 복수형으로 지정이 되어져 있음
// 	 한 페이지당 태그는 여러 번 중복이 될 수 있음(그래서 이름부터가 복수형(Elements)) => 그래서 해당 객체들을 배열로 가져옴
//   즉, 배열의 형태로 해당 태그를 반환해주는 것이다!!

// - getElementsByName(name) 
//   : 태그의 name 속성이 name과 일치하는 문서 객체를 배열로 가져옴.
// 	 id태그처럼 name 태그도 모든 속성이 가질 수 있음. 하지만 페이지 구성 단계에서는 name의 쓰임을 알 수 없음.
//   웹과 관련된 servlet jsp, spring 속성에 가서 중요한 의미를 가지게 됨! (실질적으로 살펴볼 백엔드 기술)
// 	 이 메서드도 Elements = 한 페이지에서 동일한 name을 여러 개 가질 수 있음

// - getElementsByClassName('className')
//	 공통적인 스타일 적용 = class 이름을 동일하게 지정
// 	 이 메서드도 배열의 형태로 문서객체를 가져옴

	// 태그 이용하여 접근 예시
	var headers = document.getElementsByTagName('h1'); 
	//선택하고자 하는 태그의 이름을 입력으로 넣어주면 body영역에 가서 모든 h1을 검색하게 된다. => 현재 h1이 총 3개가 있음
	//위 코드가 실행이 되면 배열의 형태로 반환을 해주게 된다!! 
	
	//자바스크립트는 자료형이 var하나이기 때문에 직관적으로 자료형을 파악하기 어려움.
	//그래서 메서드가 어떤 자료형으로 반환해주는지를 미리 알고 있어야 빠르게 코드 파악이 가능함.
	
	headers[0].innerHTML = 'getElementsByTagName-1'; //배열이기 때문에 인덱스로 접근(0부터 카운팅이 됨)하여 텍스트 수정, 첫번째 h1에 적용하도록 함
	headers[1].innerHTML = 'getElementsByTagName-2';
	headers[2].innerHTML = 'getElementsByTagName-3';
*/

/* 4. 문서 객체의 스타일 조작 
// css로 꾸민 상태는 정적인 화면 => 동적으로 꾸며주고 싶다고 할 때 document를 활용하도록 한다.

	var header = document.getElementById('header_1'); //header_1에 접근할 수 있는 문서객체를 선언해줌
	
	// 문서 객체의 스타일 조작 => style 속성을 통해서 css의 속성들을 사용할 수 있음.
	//                            style 속성은 객체형태로 이루어져있기 때문에 객체의 요소에 접근하는 방식으로 스타일 조정할 수 있다.
	header.style.border = '1px solid black'; //테두리를 동적으로 적용하고자 하는 것이다.
	//테두리를 구성하기 위해서는 3개의 속성값을 셋팅해줘야 했었음(선굵기, 모양, 색상)_속성들이 구별되어 존재하기 때문에 순서는 상관 없음 
	header.style.color = 'orange'; //텍스트의 색상을 변화시키고자 함.
	header.style.backgroundColor = 'yellow'; //배경 색상을 변화시킴
	//css에서의 속성의 이름은 카멜방식(두 단어 이상일 때 두 번째 단어부터는 첫글자가 대문자임)으로 제공을 하고 있었음. => 속성이름을 예측할 때 활용하도록 한다.
 	//이벤트에 의한 처리에 위 코드를 사용한다면 이벤트 발생 시 실시간적으로 스타일을 바꿔주는 동적효과를 부여할 수 있다.
*/

/* 5. 문서 객체 제거: 해당 태그를 제거하는 동적인 효과 적용 
// - 방법1 : body 문서 객체 바로 아래에 제거하고자 하는 문서객체가 있을 때 가능한 코드.
	var willRemove = document.getElementById('header_1');
	document.body.removeChild(willRemove); //removeChild()메소드를 활용해서 지정한 문서 객체를 제거하도록 한다. 
	//=> body바로 밑에 제거할 문서 객체가 있어야만 제거가 가능하기 때문에 removeChild()메소드의 사용은 한정적인 방법이다.

// - 방법2 : 일반적으로 문서 객체를 제거 할 때 사용하는 코드. => 태그가 어떤 위치에 있던지 공통적으로 적용할 수 있는 방법이다!!
	var willRemove2 = document.getElementById('header_2'); 
	willRemove2.parentNode.removeChild(willRemove2); //내 자신의 부모 노드로 가서 자식 중에 내 자신에 대한 정보를 넣어주면 그 위치로 찾아가서 제거를 해주게 됨!!
	//parentNode필드 : 현재 나의 위치에서 부모노드를 의미 (!!나를 감싸고 있는 위치에 부모 노드!!)
	//removeChild()메소드: 그 부모 노드의 자식 즉, 현재 나의 정보를 넣어주면서 제거하도록 한다.
*/

/* 6. 문서 객체를 활용한 예제 */
	
	var clock = document.getElementById('clock');
	
	setInterval(function(){
		var date = new Date(); //자바스크립트가 제공해주는 Date 생성자 함수를 생성
		clock.innerHTML = date.toString(); //날짜와 시간정보를 clock에 업데이트를 하도록 한다.
		//위에까지는 한번만 시간을 알려줌.
	}, 1000); //1초마다 첫번째 매개변수를 넣어준 함수를 호출함
	//시간 초마다 업데이트되도록 동적효과를 부여하도록 한다!!
	
	//문서객체를 사용하여 body영역에 접근할 때 여러 메소드를 알아야 하는 코드 작성에 번거로움이 생김
	//그래서 일반적으로 자주 사용하는 구문들을 미리 라이브러리에 작성을 해놓은 jquery가 많이 사용되어진다. => 뒤에 가서 위 내용들을 비교하면서 살펴볼 예정.

};
</script>
</head>
<body>

	<h1 id="header_1">HEADER-1</h1>

 	<img src="image.jpg" /> 

	<div> <!-- div태그: 블록 영역으로 해당영역을 차지하게끔 함. -->
		<h1 id="header_2" class="" name="">HEADER-2</h1> 
		<!-- 모든 태그들이 name이라는 속성을 가질 수 있다.(클래스나 아이디처럼 이름을 붙여줄 수 있음) => 페이지 구성단계에서는 쓰임을 알 수 없음. 
		     이 name이라는 속성은 백엔드에 서블릿jsp 스프링을 공부하게 되면 name 속성이 중요한 의미를 가지게됨
		     name의 속성도 클래스처럼 한 페이지 내에서 이름을 동일하게 사용할 수 있음 -->
	</div>

	<h1 id="clock"></h1> 

</body>
</html>


