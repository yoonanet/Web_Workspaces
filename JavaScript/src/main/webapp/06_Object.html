<!-- 
자바스크립트도 객체지향언어이다!!

자바스크립트에서의 객체는 자바의 객체와 비슷하게 제공되어지는 부분들이 있지만
                   자바와 방향성(두가지로 나뉨)에서 상이하게 제공되는 내용들이 있음.
                   
자바에서 생성된 객체를 사용하는 방법이 class라는 키워드를 사용해서 중괄호를 이용해서 테이블을 정의를 했었음 
-> new로 인스턴스를 생성(메모리 할당)하여 .연산자를 통해 접근을 했었음
 -->

<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>객체(object)</title>

<script type="text/javascript">
/* 1. 객체의 생성 방법 - 객체의 형태는 (키:요소)이다. 
//자바에서는 배열을 초기화할 때 사용을 하고 있었음. !!주의) 자바에서는 배열(자바스크립트는 []로 배열 표현), 자바스크립트에서는 객체!!
	var product = { name:'냉장고', 제조사:'한국' }; //***객체는 변수에 담아서 변수를 통해 해당 데이터에 접근해가는 방법을 공통적으로 사용한다.
	//어떤 객체에 해당되어지는 데이터를 담을 것인지를 키와 요소로 작성하며, 그 키와 요소를 통해 데이터를 관리하게 된다.
	
	//객체의 데이터 접근 방법
	alert(product.name);      //1. '변수명.키'=> 특정 메모리에 접근하는 방법은 .연산자를 통해 메모리에 접근해가는 방법을 적용하도록 한다.
	alert(product['제조사']); //2. ['키']를 통해 메모리에 접근하도록 한다. 주의) 대괄호 안에 키값을 적어줄 때 작은따옴표('')를 통해 접근을 해야한다!!
*/
	
/* 2. 객체의 속성과 메서드 => 객체는 속성과 메서드의 요소들을 통해 정의할 수 있음 
//	- 속성 : 객체 내부에 있는 하나하나의 값.
//	- 객체의 속성이 가질 수 있는 자료형. -> 정수, 실수, 문자열, boolean, 배열, 함수

	var object = { //정의방법을 살펴본 것 -> !!자바의 프레임워크에 map의 형태이다!!
		//필드의 값처럼 선언.
		useNumber:273, 
		useString:'문자열',
		useBoolean:true,
		useArray:[52, 273, 103, 32],
		//메서드: 객체의 속성 중 함수 자료형인 속성 
		method: function(){}
	};
 
// - 속성과 메서드의 구분
//	. 변수를 선언
	var person = {
		name:'홍길동',
		
		//객체 내부에 함수는 익명함수로 선언하고 키값을 지정하도록 함.
		eat:function(food){ alert('음식: ' + food); }
	};
	
	alert(person.name); // 속성 접근 방법
	person.eat('밥'); // 메서드 호출 방법: 키 값으로 메소드를 호출하듯이 사용하도록 한다.

// - this 키워드 : 자바스크립트는 this 키워드를 생략할 수 없다. (자바와 동일하게 적용되어질 수 있음)
	var person = {
		name: '홍길동',
		
		//자바에서는 필드로 정의된 데이터를 영역 내에서 다이렉트로 접근할 수 있었지만 
		//자바스크립트는 객체 안에 정의된 메소드라고 하더라도 영역 내  필드를 접근할 때는 this 키워드를 통해 접근을 해야한다.
		//즉, 중괄호를 표시하자마자 new를 하게 되는 것이고, 해당 필드에 접근 할 때는 this.을 통해 접근하도록 한다. => this: 지금 할당된 주솟값을 의미
		//    나의 객체 범위 내에서 지정된 속성(필드)이라고 하더라도 this 키워드를 꼭 활용하여 접근해야 하며 생략이 불가능하다.
		eat: function(food){
			alert(this.name+'이 '+food+'을 먹었습니다.'); //food는 전달된 매개변수이기 때문에 this를 붙이면 안됨!!
		} 
	};
	
	person.eat('밥');
*/	
	
/* 3. 객체와 반복문 
	var product = {
		name:'Eclipse & Tomcat',
		price:'Free',
		language:'한국어',
		supportOS:'Win32/64',
		subscription:true
	};
	
	
	//객체에 담긴 모든 값을 꺼내올 때는 반복문을 사용하여 출력하도록 한다.
	var output = '';
	//자바에서는 두개 이상의 데이터를 담고 있는 배열이나 컬렉션 프레임워크가 ':' 뒤에 올 수 있었음.
	for(var key in product) { //자바스크립트에서는 객체에 다양한 값들이 담겨져 있음. -> product 객체 이름을 통해 반복하면 key값들이 반환되어진다.
		output += '* ' + key + ' : ' + product[key] + '\n'; //데이터들을 하나하나씩 꺼내오면서 누적하여 보관하고자 하는 것임!!
	    //product[key]: 꺼내온 키값을 통해서 해당 value값들을 꺼내오도록 한다.
	}
	
	alert(output);
*/

/* 4. 객체와 관련된 키워드 => 객체안에서 사용할 수 있는 키워드 
	var student = { //***key값의 이름을 지을 때, 한글 속성의 이름은 지양하도록 한다. 영문을 통해 이름을 짓도록 하는 것이 권고하는 사항이다.
		name:'홍길동',
		kor:92, math:98, eng:96, sci:98
	};

// - in 키워드: 해당 키가 객체 안에 있는지 확인 ('키값' in 객체를 담은 변수명)
//              키 값이 있으면 true를 반환해주고, 키 값이 없으면 false를 반환해준다.
	var output = '';
	output += "'name' in student: " + ('name' in student) + '\n'; //in키워드를 통해 student안에 name이라는 필드가 있는지를 체크해주는 것이다.
	output += "'age' in student: " + ('age' in student);
	
	alert(output);
	
// - with 키워드 : 복잡하게 사용해야 하는 코드를 짧게 줄여주는 키워드
//	. with 키워드를 사용하지 않은 경우의 예제
	var write = '';
	write += '이름 : ' + student.name + '\n'; //선언된 객체의 속성을 읽어오는 방법이 됨.
	write += '국어 : ' + student.kor + '\n';
	write += '영어 : ' + student.eng + '\n';
	write += '수학 : ' + student.math + '\n';
	write += '과학 : ' + student.sci + '\n';
	
	alert(write);
		
//	. with 키워드를 사용하여 객체에 접근한 경우
	var write = '';
	with(student) { //객체의 이름을 입력으로 전달하고 있기 때문에 속성의 이름만으로 접근이 가능하도록 한다.
		write += '이름 : ' + name + '\n'; 
		write += '국어 : ' + kor + '\n';
		write += '영어 : ' + eng + '\n';
		write += '수학 : ' + math + '\n';
		write += '과학 : ' + sci + '\n';
	}
	
	alert(write);
*/

/* 5. 객체의 속성 추가와 제거 
//	- 동적 속성 추가/제거: 처음 객체 생성하는 시점 이후에 객체의 속성을 추가하거나 제거하는 것.

	//. 빈 객체를 생성
	var student = {
		이름:'홍길동', 
		취미:'악기' //마지막 데이터일 때는 콤마를 생략하도록 하는 것이 원칙이다.
		
		//특기:'프로그래밍',
		//장래희망:'훌륭한 프로그래머'
		//!!아래의 코드가 이 코드와 동일한 의미임!!
	};
	
	//. 동적으로 속성을 추가 => 객체명.새로운 키값 = '삽입할 데이터';
	//                          '.'을 통해 추가하고 싶은 키의 '='하여 value를 담아주면 됨.
	//student.이름 = '홍길동';
	//student.취미 = '악기';
	student.특기 = '프로그래밍';
	student.장래희망 = '훌륭한 프로그래머';
	
	//. 동적으로 메서드 추가
	//  ↓ 이는 객체 안에 선언되어져 있는 함수라 하여 메소드라고 불러주고 있다.(이 개념은 자바와 동일)
	student.toString = function(){ 
		var output = '';
		
		for(var key in this) { //student객체 안에 정의하는 메소드일 경우에는 this라고 하는 키워드를 이용해서 in 다음에 넣어준다고 하면
			                   //객체 이름을 따로 넣어주지 않아도 된다.
			if(key != 'toString'){ //키의 값 중에서 현재 작성하는 메소드만 빼고 출력하도록 조건문을 걸었음.
				output += key + ' : ' + this[key] + '\n'; 
			}
		}
		
		return output; 
	}
	
	//alert(student.toString()); //나중에 추가된 속성도 정상적으로 출력되는 것을 확인할 수 있다.
	alert(student); //객체이름만을 입력으로 넣음 -> toString메소드를 호출하지 않아도 toString을 호출한 것이 똑같이 출력됨.
	
	//자바에서 출력(println)과 관련된 입력으로 참조변수를 넣어주면 내부에서 toString메소드를 호출하게끔 구현이 되어져 있음 
	//=> 자료형 용도에 대한 설명에 의미(주석으로 대체가 됐음) =>  alert도 이러한 개념이 동일하다.
	
	//alert도 입력으로 전달되어진 데이터를 출력하는 의도이다.
	//따라서, 객체를 가리키는 변수를 데이터로 넣어주면 내부에서는 
	//똑같이 toString이라고 하는 메소드를 호출해주게끔 기능이 구현되어져 있다. (오버라이딩의 컨셉을 동일하게 가져간 것임.)
	//***직접 메소드를 호출하는 것과 자료형을 넣어주는 것에 동작상에 차이점은 
	//   -> 직접 메소드를 호출하면 그 메소드를 쳐다보면서 호출하게 되는 것이고, 
	//      참조변수를 넣어주게 되면 참조변수 자체에서 오버라이딩된 메소드를 호출하게 되는 차이점이 있는 것이다.
	
	
	// . 객체의 속성 제거 - delete(객체명.키값)함수를 활용
	delete(student.장래희망); 
	alert(student);
*/
	
	
/* 6. 생성자 함수(독립적인 개념) -> 자바의 객체와 연관지어서 보면 접근성이 더 높음 
// -> 자바스크립트에서 생성자는 함수의 일환이라서 function을 통해 정의할 수 있음
// - new 키워드를 사용해 객체를 생성할 수 있는 함수. 
// - 생성자 함수를 사용한 객체의 생성과 출력.
// - 그냥(일반적인) 함수를 사용해 객체를 리턴하는 방법과 차이가 없어 보임.
	
	//정의방법이 선언적함수와 동일하다!!
	//=> 프로그램의 오류가 나지 않는 관용적인 방법을 통해 선언적함수 같은 경우 첫글자를 소문자로 지정하는 것이 일반적이다.
	//   또한, 생성자함수같은 경우 첫글자를 대문자로 정의를 해서 함수의 이름을 보면서 선언적함수와 생성자함수를 구분할 수 있도록 한다. 
	//   (ex.참조자료형에서 첫글자를 대문자로 지정하는 것과 같은 관점으로 생각.)
	
	function Student(name, korean, math, english, science){ //데이터 저장 틀, 생성자함수는 자바의 클래스개념과 매핑을 시켜서 보기
	//클래스와 매핑을 하여 생각한다고할 때 생성자 함수 안에서 필드를 생성하는 형태이기 때문에 별도로 생성자를 정의할 필요가 없는 것임!
	
		// 속성: !!생성자 함수를 통해 데이터를 전달받아서 초기화를 해주는 형태인 것이다!!
		//[선언적함수와 구분] this.을 통해서 필드를 생성하고 있으면 생성자함수이다. (선언적함수는 지역변수의 개념으로 this.을 사용하지 않음) 
		this.이름 = name; //!!필드는 this키워드를 생략할 수 없다는 것을 꼭 기억하기!!
		this.국어 = korean;
		this.수학 = math;
		this.영어 = english;
		this.과학 = science;
		
		// 메서드 (키값으로 함수를 관리할 수 있도록 한다.)
		// 주의) 자바스크립트에서는 같은 영역 안이라고 하더라도 속성에 접근할 때는 this키워드와 함께 사용을 해주도록 한다.
		this.getSum = function(){ //각 과목별 총합을 계산해주는 기능
			return this.국어+this.수학+this.영어+this.과학;
		};
		
		this.getAverage = function(){ //평균을 구해주는 기능
			//같은 영역 안에서 함수에 접근할 때도 this키워드 붙여주기!!
			return this.getSum() / 4;
		};
		
		//자바에 Object에 정의된 toString을 생각!! 
		//=> 클래스에 대한 의미는 주석문에 의해 전달이 되기 때문에 개발자의 의도대로 사용되지 않음, 
		//   주로 필드에 저장되어져 있는 값들을 확인하는 개념에 의미로 테스트의 단계에서 활용 (프로젝트가 완성되어 서비스되어지기 전까지 의도된 대로 출력이 되는지 확인하는 용도임!!)
		//   자바스크립트에서도 출력메소드에 오버라이딩하여 동작이 되는 것과 똑같이 출력을 하여 보여주게끔 구현해주고 있었던 기능이 똑같이 적용되고 있는 것이다.
		//   즉, alert을 호출하면서 참조자료형을 넣어주면 toString이 오버라이딩개념으로 출력이 되어진다. 
		//       (오버라이딩의 개념은 자바스크립트에서 따로 없지만 자체적인 처리를 해주고 있는 것임!)
		this.toString = function(){
			return this.이름+': '+this.getSum()+', '+this.getAverage();
		};
		
	}
	
	//여러 객체를 관리하는 배열을 활용(데이터셋_인스턴스를 배열로 저장하고자 함)
	var students = [];
	
	//배열에 데이터 저장 - .push()메소드를 활용한다.
	students.push(new Student('홍길동', 87, 98, 88, 95)); //생성자함수를 활용하기 위해서는 메모리가 할당이 되어져야 하기 때문에 new를 활용한다. (메모리 할당 요청)
														  //배열 안에서만 사용할 의도라면 다이렉트로 객체를 생성하는 코드로써 한줄로 작성하도록 한다.
	students.push(new Student('홍길서', 92, 88, 96, 90));
	students.push(new Student('홍길남', 84, 96, 78, 75));
	students.push(new Student('홍길북', 77, 88, 78, 75));
	students.push(new Student('김길동', 82, 88, 80, 90));
	students.push(new Student('이길동', 67, 88, 98, 92));
	
	//배열에 데이터가 잘 저장이 되어져 있는지 확인
	var output = '이름		총점		평균\n'; //인폼의 개념으로 헤더 출력
	output += '-------------------------------------\n';
	
	for(var i in students) { //전체 데이터의 갯수만큼 점수데이터를 변수에 담아서 반복시킴.
		output += students[i].toString()+'\n';
	}
	
	alert(output);
*/	
	
/*
[자바스크립트에서의 메소드와 함수의 구분]
자바스크립트에서는 객체안에 기능이 정의될 때 메소드라 하고, 
function이라는 키워드를 이용해서 객체와 상관없이 정의할 수 있는 주체를 함수(익명, 선언적으로 나뉨)라고 말함. 
	 
!!자바스크립트는 브라우저에 최적화되어진 프로그래밍 언어이다 보니까 사용의 한계성에서 브라우저에 제한이 된다!!
그렇게 제한이 되어지다 보니까 일반 프로그래밍과 같이 디테일한 명령을 처리할 수 있는 문법요소를 제공해주지 않는다.
bom(내일 배움)보다는 jqurey라는 라이브러리를 사용하는 것이 일반적임.
*/	
	
/* 7. 프로토타입(prototype) 
// ***공통이 되어지는 기능의 공간은 하나만 할당해서 모든 객체들이 참조할 수 있게끔 
//    구조를 정의해주는 것이 효율적이기 때문에 자바스크립트에서 정의된 개념인 것이다. (static과 접목시켜서 생각)
// - 생성자 함수를 사용해 생성된 객체가 공통으로 가지는 공간.
// - 자바스크립트의 모든 함수는 변수 prototype을 갖고 prototype은 객체다.

// new를 할 때마다 개별적으로 필드와 메서드의 공간이 할당이 될 것이다. 
// => 데이터값이 다르기 때문에 필드의 공간은 별도로 생성이 되는 것이 맞지만
//    메소드와 같은 경우, 같은 기능이기 때문에 별도의 공간을 따로 생성할 필요가 있을 것인지에 대한 의문이 생길 수 있다. 
// => 공통된 기능에 한해서 공통된 공간을 가지도록 한다면 더 효율적일 것이다!! 
//    이 부분을 생각하게 된다면 자바에서는 static(범용적으로 사용하는 기능은 하나의 공간을 만들고 참조하여 사용할 수 있게끔 한다)을 생각할 수 있다. 
//    -> 이 static은 메모리에서 method영역(프로그램의 시작과 끝까지만 존재)에 저장된다.
//    이러한 static의 개념이 프로토타입과 동일하게 적용된다.

	function Student(name, korean, math, english, science){  
		//속성
		this.이름 = name; 
		this.국어 = korean;
		this.수학 = math;
		this.영어 = english;
		this.과학 = science;
	}	
	
	//생성자를 정의하자마자 prototype라는 필드를 제공해주게 된다 => 따라서 '.' 을 통해 prototype필드 이름으로 접근하도록 한다.
	//[코드 의미↓] 정의한 함수를 Student에 prototype영역에 할당을 해주게 되는 것임 
	Student.prototype.getSum = function(){ //(인스턴스들이 getSum메소드를 참조하면서 사용할 수 있게끔 정의한 것임!!)
		return this.국어+this.수학+this.영어+this.과학;
	};

	Student.prototype.getAverage = function(){ 
		return this.getSum() / 4;
	};
	
	Student.prototype.toString = function(){
		return this.이름+': '+this.getSum()+', '+this.getAverage();
	};
 

	
	
	var students = [];
	
	students.push(new Student('홍길동', 87, 98, 88, 95)); 
	students.push(new Student('홍길서', 92, 88, 96, 90));
	students.push(new Student('홍길남', 84, 96, 78, 75));
	students.push(new Student('홍길북', 77, 88, 78, 75));
	students.push(new Student('김길동', 82, 88, 80, 90));
	students.push(new Student('이길동', 67, 88, 98, 92));
	
	var output = '이름		총점		평균\n';
	output += '-------------------------------------\n';
	
	for(var i in students) { 
		output += students[i].toString()+'\n';
	}
	
	alert(output);
	//결과적으로는 생성자함수에 메소드를 생성한 것과 동일하지만
	//하드웨어적으로 보면 공통으로 메모리 하나만 생성하여 처리를 해주기 때문에 퍼포먼스가 향상이 되고 메모리도 절약이 된다.
*/		
	
/* 8. instanceof 키워드 - 반환형은 boolean값이다. 
// 자바에서의 instanceof 용도: 상속의 관계하에서 다형성으로 자식을 바라볼 수 있었음. 이때, 메소드에서 최상위 부모 자료형으로 하여금 자식을 다 전달받을 수 있었다.
//                             하지만 메소드 안에 들어왔을 때 어떤 자료형이 들어왔는지 알 수가 없었다. 그래서 그 자료형을 알 수 있게끔 판단해주는 연산자가 instanceof였던 것이다.
//                             여기서 instanceof의 핵심은 상속과 다형성이다.
// 하지만 자바스크립트에서는 상속에서 공식적인 문법적 약속이 없음 -> 그렇기 때문에 instanceof는 자바와 다른 용도로 사용될 목적으로 제공하고 있는 함수라는 것을 알고 있어야 한다.
// - 인스턴스: 생성자 함수를 통해 new라고 하는 키워드를 통해서 만들어진 객체.
// - 해당 객체가 어떠한 생성자 함수를 통해 생성됐는지를 확인할 때 사용하는 키워드.
//   (자바의 확대된 개념으로 제공하는 키워드가 아니다!!)

	// 생성자 함수를 선언 (첫글자는 대문자, 생성자 함수 내부에는 속성과 메소드를 선언할 수 있음)
	function Student(name){ this.name = name; }
	
	var student = new Student('홍길동');
	
	alert(student instanceof Number); // false
	//'student변수야 너는 Number라는 생성자 함수로 만들어진 인스턴스니?' 라고 물어보는 용도임. 
	//instanceof제공의도) 참조변수의 자료형을 체크하기 위한 의도로 제공해주고 있는 것이다.
	//                    즉, 인스턴스의 생성자함수의 타입을 확인하는 용도로 자바스크립트에서는 instanceof연산자를 사용하는 것이다!!
	alert(student instanceof Number); // true
*/	
	
/* 9. 상속 
   	=> 자바스크립트에서는 상속이 문법적으로 공식 약속되어져 있는 개념은 전혀 없지만 
       객체를 지향하는 언어이기 때문에 상속처럼 코드를 적용해서 사용할 수 있는 처리 방법(우회적인 방법임)이 코드상으로 구현을 할 수는 있는 것이다!!
    
	// - 생성자 함수를 선언
	function Rectangle(w, h) {
   		var width = w;
   		var height = h; // this.width / this.height로 선언하지 않는 이유 -> 보관하고 있을 필요가 없기 때문에 지역변수로 선언한 것이다.
   		
   		this.getWidth = function(){ return width; }
   		this.getHeight = function(){ return height; }
   		
   		this.setWidth = function(value) {
   			if(value < 0) { 
   				throw '길이는 음수일 수 없습니다.'; //throw키워드: 예외를 발생시켜서 catch문에 전달하기 위한 동작
   			} else {
   				width = value;
   			}	
   		}
   		
   		this.setHeight = function(value) {
   			if(value < 0) { 
   				throw '길이는 음수일 수 없습니다.'; 
   			} else {
   				height = value;
   			}	
   		}
   	}
	
   	//생성자 함수가 정의되는 순간 prototype필드를 생성해줌
   	//↓ Rectangle로 생성한 모든 인스턴스들이 공통적으로 사용할 수 있는 메소드를 생성한 것이다.
   	Rectangle.prototype.getArea = function(){ //넓이 계산 기능
   		return this.getWidth() * this.getHeight();
   	}
	
   	
	//var rectangle = new Rectangle(5, 7); //참조변수를 생성하여 생성자함수의 주소값을 저장
	//rectangle.setWidth(-2); //예외가 발생되어 지정한 오류메시지가 출력됨
	
	//alert('AREA : ' + rectangle.getArea()); //넓이를 출력
	
	function Square(length){ //정사각형으로 하나의 값만 전달받게끔 정의
		this.base = Rectangle; // 생성자함수를 등록하여 사용할 수 있다!!
		// => 생성자함수도 함수이므로 변수에 담아서 관리할 수 있는 개념으로 생각하면 된다.
		this.base(length, length); //함수의 개념으로 두 개의 값을 전달하는 형태의 코드를 추가함.
	}
	
	Square.prototype = Rectangle.prototype; //!!prototype의 서로 영역을 공유하는 개념으로 사용하는 것임!! 
	=> 마치 부모가 자식에게 메소드를 상속하는 것과같은 효과를 나타낸 것 뿐이다. (상속의 우회적인 의미로 공유로 효과를 내는 것)
	
	var rectangle = new Rectangle(5, 7); //인스턴스 생성
	var square = new Square(5);
	
	alert(rectangle.getArea());
	alert(square.getArea()); // rectangle의 prototype에 저장되어져 있는 메소드를 호출할 수 있게 된다. 
	                         // 이는 rectangle prototype을 공유했기 때문에 square에 정의되어 있지 않아도 호출이 가능한 것이다!
*/	


	
</script>

</head>
<body>

</body>
</html>